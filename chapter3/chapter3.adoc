== My Solution

=== Overview

This chapter details my solution to the problem.
The traditional software engineering task-based organization is used.
Section 1 describes the requirements of the solution, focusing on features.
Section 2 describes the architecture of the solution.
Section 3 describes the implementation of the solution.
Hardware and software topics are covered in section 3, from physical
installation to the graphical user interface.
Section 4 describes the testing regime undertaken during the development of
this project.

=== Requirements

==== Features

=== Software Architecture

==== Platform

Negativuserland was designed with simplicity, performance, and modularity in
mind.
Its target hardware is cheap single-board computers.
These motivations influenced the choice of a development platform.



==== Organization

The project is designed into several service components, each with a
well-defined role and programming interface.

=== Implementation

==== Platform

===== Bootloader

The bootloader chosen for this project is _Das U-Boot_ <<uboot>>, an open
source bootloader supporting several embedded architectures. This software
exposes all the necessary facilities to locate, load and execute the real
operating system kernel which will host the Negativuserland software.

===== Operating System

The operating system chosen for this project is Linux, an open source operating
system kernel that runs on many embedded computer systems as well as larger ones
<<linux-readme>>. Much of the software written for this project will run on any
UNIX-like operating system, however.

===== Frameworks

When developing applications, the choice of frameworks can be the true driving
influences in the implementations of a project. While this project has chosen
Linux as its operating system, it has been developed heavily with portable
libraries that can be built (and run) on other operating systems and
architectures. This project has chosen to only build upon open source libraries.

At the lowest level, all the application code of this project uses GLib
<<glib-overview>>, a portable utility library providing many data structures and
support functionality to assist application development. GLib also includes
GObject, a C-based object-oriented type system, and GIO, an asynchronous
Input/Output (I/O) library with many more additional support features.
Importantly, GIO provides a client and server implementation of the D-Bus
protocol using its asynchronous I/O model.

===== Programming Language

Initially, this project was programmed in Vala, a language with a similar
syntactical appearance to C++\#++ but targeting the GObject type system. This is
achieved by the Vala compiler generating GObject-style C code and mapping
documentation annotations as well as custom metadata to Vala constructs. Since
Vala is just a code generator, its use does not require a virtual machine,
runtime interpreter, or garbage collector. These properties are advantageous to
embedded software development where processing speed, memory usage, and power
consumption are more scarce than desktop or server environments. Vala allows for
fairly rapid prototype development due to its significantly smaller amount of
boilerplate code necessary to define and implement object-oriented constructs
such as interfaces and classes (as well as subclassing). Through the development
of the project, many difficulties were experienced with this language that
required the author to fix bugs within the Vala language or its bindings to
external libraries. Furthermore, the nature of the Vala language and libraries
implemented with the GObject type system introduce a maintenance requirement for
the Vala bindings to a specific library. Changes to APIs and incorrect
trascription or scanning will lead to discrepancies between the original C API
of a library and the generated or manually maintained Vala bindings. These
deficiencies, combined with the declining activity of the Vala project have
disqualified the language from being the primary language of this project.

Due to the project GObject Introspection <<gobject-introspection>>, many more
programming languages are available to the GObject programmer. GObject
Introspection provides automatic bindings from GObject libraries to JavaScript,
Python, Lua, Perl, Ruby, Guile, and other languages <<gi-users>>. Similar to
Vala, which is partially compatible with GObject Introspection, projects
employing GObject Introspection are subject to mismatched bindings. Furthermore,
attempts to map GObject semantics into a specific programming language's idioms
are not guaranteed.

The compound effects of developing with non-native programming languages during
the development process eventually led to their abandonment in favor of
GObject-style C. The C11 revision of C was eventually chosen for this project
since it is fully supported by the compilers GCC <<gcc-c11-compatibility>> and
Clang <<clang-c11-compatibility>>. This choice provides full control of all
library APIs with the slightly inconvenient syntax of the GObject type system's
C macros.

===== Build System

Build systems are an important part of any sufficiently large software project.
They are responsible for configuring any target-specific options and producing
target artifacts, the part of the project that will be experienced byt the
end-user. The most common build system for UNIX-style projects is make, part of
the POSIX standard. Limitations in make have repeatedly influenced efforts in
producing new build systems over the years. Among the replacements, GNU
Autotools and CMake are the most popular for UNIX-style projects. GNU Autotools,
also known as the GNU Build System, is a combination of GNU Autoconf
<<gnu-autoconf>>, GNU Automake, <<gnu-automake>>, GNU Libtool <<gnu-libtool>>,
and GNU Make <<gnu-make>>. These tools are orchestrated in order to provide a
fully portable solution for building software projects.
quantity, having
